# Task Manager

#### Video Demo:  [https://youtu.be/kqJsDiXAMY8]

#### Description:

The **Task Manager** is a command-line application designed to help users efficiently manage their daily tasks. The application allows users to perform basic task management operations such as adding, deleting, viewing, and marking tasks as completed. The main goal of this project is to create a simple yet functional tool that could serve as a personal task organizer. This program provides a practical way to handle to-do lists, offering basic features that are essential for personal task management.

All tasks are stored persistently using a JSON file, ensuring that users’ tasks are saved between sessions. The program has been implemented in Python and includes several functions to manipulate the task data, as well as tests using the `pytest` framework to ensure the reliability of the core functions.

The application consists of a main function and several additional functions that handle the core operations. These functions are tested using automated test cases provided in a separate test file.

### Features

1. **Add Task**: Users can add new tasks by providing a description and an optional due date. Each task is assigned a unique ID to differentiate it from other tasks.

2. **Delete Task**: Users can delete tasks from the list by specifying the task ID. This feature ensures that users can easily remove tasks they no longer need to complete.

3. **View Tasks**: Users can view all tasks stored in the system. This view includes the task description, the due date (if any), and the status of the task (whether it's pending or completed).

4. **Mark Task as Completed**: Users can mark tasks as completed by providing the task ID. This feature helps users keep track of their progress.

5. **Persistent Data Storage**: Tasks are saved in a `tasks.json` file, ensuring that all task data is preserved even when the program is closed.

6. **Command-Line Interface**: The task manager operates through a command-line interface (CLI), making it easy to use from any terminal.

### How the Project Works

The program starts by loading any existing tasks from the `tasks.json` file. If the file does not exist, it is created automatically when the first task is added. The user is then presented with a menu of options, such as adding a task, viewing tasks, deleting a task, or marking a task as completed. The program will continue running until the user chooses to exit.

When the user adds a task, they are prompted to provide a description and, optionally, a due date. The program then generates a unique ID for the task and saves it in the `tasks.json` file. The JSON file stores all tasks as a list of dictionaries, each dictionary containing the task's description, due date, and completion status.

Deleting a task involves specifying the task ID, which is then used to identify and remove the task from the list. Similarly, marking a task as completed requires the task ID, which the program uses to update the task’s status in the JSON file.

The command-line interface is simple and easy to navigate, allowing users to quickly interact with their tasks.

### Files

- `project.py`: This file contains the main program and all of the task management functions, including functions for adding, deleting, viewing, and updating tasks. It also contains the main function that handles user input and orchestrates the program's flow.

- `test_project.py`: This file contains the test cases for the functions in `project.py`. These tests ensure that the task management functions work as expected. The test cases are written using `pytest`, which allows for easy and automated testing.

- `requirements.txt`: Lists the Python libraries required for the project. In this case, it includes the pytest library for running the tests.

- `tasks.json`: This file is used to store the tasks. It is automatically generated by the program and contains all task data in JSON format. Each task is stored as a dictionary with keys for the description, due date, and status.

- `README.md`: This file contains the documentation for the project, including details about the features, files, and design decisions.

### Design Choices

1. **JSON for Data Storage**: I chose to use JSON to store the task data because it provides a simple, human-readable format that is easy to work with in Python. JSON files are lightweight and allow for easy manipulation of structured data, making them ideal for a task manager. Since the task data consists of descriptions, due dates, and statuses, representing each task as a JSON object works perfectly for this use case.

2. **Command-Line Interface**: I opted for a command-line interface to keep the program simple and lightweight. While a graphical interface could have been developed, the CLI provides a minimalistic and efficient way for users to interact with the program without the need for additional libraries or frameworks.

3. **Unique Task IDs**: Each task is assigned a unique ID to allow for easy identification and manipulation. This approach simplifies operations such as deleting tasks and marking them as completed, as users can directly reference the ID.

4. **Test Coverage**: Writing tests for the key functions in `project.py` was a crucial part of the project. Using `pytest` allows for automated testing, ensuring that the core functionality of the application remains reliable even after making changes or adding new features.

5. **Scalability**: While this project was designed as a simple task manager, the structure allows for future expansion. For example, more features such as task prioritization or notifications could be added later without major changes to the existing codebase.

### Conclusion

This project demonstrates the fundamental aspects of building a command-line task manager in Python. By using JSON for data storage, a command-line interface for simplicity, and implementing tests for reliability, the project fulfills the requirements of the course while providing a practical tool for task management. Future improvements could include adding more advanced features, such as task categorization or a graphical interface, but the current implementation offers a solid foundation for managing tasks efficiently.
